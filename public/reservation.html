<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Redraw Non-Overlapping Circles</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
      }
      canvas {
        border: 1px solid #ccc;
        margin-bottom: 10px;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      button:hover {
        background-color: #0056b3;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <button id="redrawButton">Redraw Circles</button>
    <script>
      const socket = io(`${location.protocol}//${location.host}`, {
        transports: ["websocket"],
      });
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const radius = 10;
      let circles = [];

      // 캔버스에서 특정 원 영역만 다시 초기화
      function clearCircle(x, y) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, radius + 1, 0, Math.PI * 2); // 정확한 원 영역
        ctx.clip(); // 클리핑 경로 설정
        ctx.clearRect(
          x - radius - 1,
          y - radius - 1,
          2 * (radius + 1),
          2 * (radius + 1)
        ); // 해당 영역만 지움
        ctx.restore();
      }

      // 특정 원 다시 그리기
      function updateCircle(circle) {
        clearCircle(circle.x, circle.y); // 해당 원 주변만 지움

        const color = circle.selectedBy
          ? circle.selectedBy === socket.id
            ? "lightgreen" // 내가 선택한 원
            : "red" // 다른 사람이 선택한 원
          : "blue"; // 선택되지 않은 원

        drawCircle(circle.x, circle.y, color);
      }

      // 원 그리기 함수
      function drawCircle(x, y, color) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.stroke();
      }

      // 캔버스 다시 그리기
      function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        circles.forEach(({ x, y, selectedBy }) => {
          if (selectedBy === socket.id) {
            drawCircle(x, y, "lightgreen"); // 내가 선택한 원
          } else if (selectedBy) {
            drawCircle(x, y, "red"); // 다른 사람이 선택한 원
          } else {
            drawCircle(x, y, "blue"); // 선택되지 않은 원
          }
        });
      }

      // 서버에서 캔버스 상태 업데이트를 받았을 때
      socket.on("updateCanvas", (serverState) => {
        circles = serverState; // 서버 상태 동기화
        redrawCanvas(); // 캔버스 다시 그리기
      });

      // 서버에서 특정 원 정보 업데이트를 받았을 때
      socket.on("updateCircle", (updatedCircle) => {
        const index = circles.findIndex(
          (circle) => circle.id === updatedCircle.id
        );
        if (index !== -1) {
          circles[index] = updatedCircle; // 해당 원 정보 업데이트
          updateCircle(updatedCircle); // 부분 업데이트
        }
      });

      // 선택 실패 메시지 처리
      socket.on("selectionFailed", ({ message }) => {
        alert(message); // 사용자에게 알림
      });

      // 원 클릭 이벤트 처리
      canvas.addEventListener("click", (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // 클릭한 원 찾기
        const clickedCircle = circles.find(({ x: cx, y: cy }) => {
          const dx = cx - x;
          const dy = cy - y;
          return Math.sqrt(dx * dx + dy * dy) < radius;
        });

        if (clickedCircle) {
          socket.emit("selectCircle", { circleId: clickedCircle.id }); // 서버에 선택 요청
        }
      });

      // 버튼 이벤트 리스너
      document.getElementById("redrawButton").addEventListener("click", () => {
        socket.emit("requestNewCircles"); // 서버에 새 원 생성 요청
      });

      let remainingTime = 0;
      let intervalId = null; // 현재 실행 중인 타이머 ID

      // 원에 대한 정보 표시
      function displayCircleInfo(circle, event) {
        const infoBox = document.getElementById("circleInfo");

        if (circle) {
          // 기존 타이머 제거
          if (intervalId) {
            clearInterval(intervalId);
            intervalId = null;
          }

          // 남은 시간 계산
          remainingTime = circle.expirationTime
            ? Math.max(0, (circle.expirationTime - Date.now()) / 1000).toFixed(
                2
              )
            : "0.00";

          // 정보 표시
          infoBox.textContent = `Circle ID: ${circle.id}
Selected By: ${circle.selectedBy || "None"}
X: ${circle.x.toFixed(2)}
Y: ${circle.y.toFixed(2)}
Remaining Time: ${remainingTime} seconds`;

          infoBox.style.visibility = "visible";

          // 마우스 위치에 따라 박스 위치 조정
          infoBox.style.top = `${event.clientY + 15}px`;
          infoBox.style.left = `${event.clientX + 15}px`;

          // 남은 시간이 있을 경우, 초 단위로 갱신
          if (remainingTime > 0) {
            intervalId = setInterval(() => {
              remainingTime = circle.expirationTime
                ? Math.max(
                    0,
                    (circle.expirationTime - Date.now()) / 1000
                  ).toFixed(2)
                : "0.00";

              if (remainingTime === "0.00") {
                clearInterval(intervalId);
                intervalId = null;
              }

              // 갱신된 정보 표시
              infoBox.textContent = `Circle ID: ${circle.id}
Selected By: ${circle.selectedBy || "None"}
X: ${circle.x.toFixed(2)}
Y: ${circle.y.toFixed(2)}
Remaining Time: ${remainingTime} seconds`;
            }, 100); // 100ms마다 갱신
          }
        } else {
          infoBox.textContent = "";
          infoBox.style.visibility = "hidden"; // 숨기기
          if (intervalId) {
            clearInterval(intervalId);
            intervalId = null; // 기존 타이머 제거
          }
        }
      }

      // 마우스 이동 이벤트 처리
      canvas.addEventListener("mousemove", (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // Hover 중인 원 찾기
        const hoveredCircle = circles.find(({ x: cx, y: cy }) => {
          const dx = cx - x;
          const dy = cy - y;
          return Math.sqrt(dx * dx + dy * dy) < radius;
        });

        displayCircleInfo(hoveredCircle, event);
      });

      // HTML에 정보 표시용 박스 추가
      const infoBox = document.createElement("div");
      infoBox.id = "circleInfo";
      infoBox.style.position = "absolute";
      infoBox.style.pointerEvents = "none"; // 마우스 이벤트 무시
      infoBox.style.backgroundColor = "rgba(0, 0, 0, 0.7)"; // 반투명 검은색
      infoBox.style.color = "white";
      infoBox.style.padding = "8px 12px";
      infoBox.style.borderRadius = "5px";
      infoBox.style.fontFamily = "Arial, sans-serif";
      infoBox.style.fontSize = "12px";
      infoBox.style.whiteSpace = "pre-line"; // 개행 처리
      infoBox.style.visibility = "hidden"; // 기본 숨김
      infoBox.style.zIndex = "1000"; // 상단에 표시
      document.body.appendChild(infoBox);
    </script>
  </body>
</html>
